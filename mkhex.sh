#!/usr/bin/env bash


#
# Copyright 2015 Gu Zhengxiong <rectigu@gmail.com>
#
# GPL
#


regex='\t([0-9a-f]{2}\s)+'

if [[ $# -ge 1 ]]
then
    hex=$(objdump -d "$1" | grep -oP $regex)

    if [[ $2 -ge 2 ]]
    then
        cat <<EOF
/*
 * This file was automatically generated by mkhex.sh,
 * which, together with the complete
 * and heavily commented assembly source code
 * for this shellcode, is available at
 * https://github.com/NoviceLive/shellcoding.
 *
 * For those curious heads
 * striving to figure out what's under the hood.
 */


# include <stdlib.h>
# include <stdio.h>
# include <string.h>

EOF
        if [[ $2 -eq 3 ]]
        then
            cat <<EOF
# include <stdint.h>

# include <sys/mman.h>
EOF
        fi

        if [[ $2 -eq 4 ]]
        then
            cat <<EOF
# include <windows.h>
EOF
        fi
        cat <<EOF


int
main(void)
{
EOF
        printf '  char *shellcode = "'
    fi

    c=0
    for i in $hex
    do
        if [[ $2 -ge 2 ]] && [[ $c -eq 10 ]]
        then
            c=0
            printf '"\n    "'
        fi

        if [[ $2 -eq 1 ]]
        then
            fmt='%s'
        else
            fmt='\\x%s'
        fi

        printf $fmt "$i"

        c=$(($c + 1))
    done

    if [[ $2 -ge 2 ]]
    then
        printf '";\n\n'
        if [[ $2 -eq 3 ]]
        then
            cat <<EOF
  int ret = mprotect ((void *)((uintptr_t)shellcode & ~4095), 4096,
    PROT_READ | PROT_WRITE | PROT_EXEC);

  if (ret) {
    printf ("mprotect\n");
    return EXIT_FAILURE;
  }

EOF
        fi
        if [[ $2 -eq 4 ]]
        then
            cat <<EOF
  DWORD why_must_this_variable;
  BOOL ret = VirtualProtect (shellcode, strlen(shellcode),
    PAGE_EXECUTE_READWRITE, &why_must_this_variable);

  if (!ret) {
    printf ("VirtualProtect\n");
    return EXIT_FAILURE;
  }

EOF
        fi
        cat <<EOF
  printf("strlen(shellcode)=%d\n", strlen(shellcode));

  ((void (*)(void))shellcode)();

  return EXIT_SUCCESS;
}
EOF
    fi
else
    printf 'no binaries specified\n'
fi
