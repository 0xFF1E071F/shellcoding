#!/usr/bin/env bash


#
# Copyright 2015 Gu Zhengxiong <rectigu@gmail.com>
#


if [[ $# -lt 1 || (! -f "$1") ]]
then
    printf '%s\n' 'Invalid Arugment!'
    cat <<EOF
Usage: $0 file -e|--escape -r|--raw -c|--c -l|--linux -w|--windows
EOF
    exit 233
fi

case "$2" in
    -e|--escape)
        flag=0;;
    -r|--raw)
        flag=1;;
    -c|--c)
        flag=2;;
    -l|--linux)
        flag=3;;
    -w|--windows)
        flag=4;;
    *)
        flag=0;;
esac


regex='\t([0-9a-f]{2}\s)+'

hex=$(objdump -d "$1" | grep -oP $regex)

if [[ $flag -ge 2 ]]
then
    cat <<EOF
/*
 * This file was automatically generated by mkhex.sh,
 * which, together with the complete
 * and heavily commented assembly source code
 * for this shellcode, is available at
 * https://github.com/NoviceLive/shellcoding.
 *
 * For those curious heads
 * striving to figure out what's under the hood.
 */


# include <stdlib.h>
# include <stdio.h>
# include <string.h>

EOF
    if [[ $flag -eq 3 ]]
    then
        cat <<EOF
# include <stdint.h>

# include <sys/mman.h>
EOF
    fi

    if [[ $flag -eq 4 ]]
    then
        cat <<EOF
# include <windows.h>
EOF
    fi
    cat <<EOF


int
main(void)
{
EOF
    printf '  char *shellcode = "'
fi

c=0
for i in $hex
do
    if [[ $flag -ge 2 ]] && [[ $c -eq 10 ]]
    then
        c=0
        printf '"\n    "'
    fi

    if [[ $flag -eq 1 ]]
    then
        fmt='%s'
    else
        fmt='\\x%s'
    fi

    printf $fmt "$i"

    c=$(($c + 1))
done

if [[ $flag -ge 2 ]]
then
    printf '";\n\n'
    if [[ $flag -eq 3 ]]
    then
        cat <<EOF
  int ret = mprotect ((void *)((uintptr_t)shellcode & ~4095), 4096,
    PROT_READ | PROT_WRITE | PROT_EXEC);

  if (ret) {
    printf ("mprotect\n");
    return EXIT_FAILURE;
  }

EOF
    fi
    if [[ $flag -eq 4 ]]
    then
        cat <<EOF
  DWORD why_must_this_variable;
  BOOL ret = VirtualProtect (shellcode, strlen(shellcode),
    PAGE_EXECUTE_READWRITE, &why_must_this_variable);

  if (!ret) {
    printf ("VirtualProtect\n");
    return EXIT_FAILURE;
  }

EOF
    fi
    cat <<EOF
  printf("strlen(shellcode)=%d\n", strlen(shellcode));

  ((void (*)(void))shellcode)();

  return EXIT_SUCCESS;
}
EOF
fi
